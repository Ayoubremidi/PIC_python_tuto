{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# EXO 1.2 :  Calcul d’un prix TTC\n",
    "# Question 1\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 582,
   "metadata": {},
   "outputs": [],
   "source": [
    "def prix_ttc(ht, taux_tva):\n",
    "    return ht * (1 + taux_tva / 100)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Question 2"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 583,
   "metadata": {},
   "outputs": [],
   "source": [
    "def prix_ht(ttc, taux_tva):\n",
    "    return ttc / (1 + taux_tva / 100)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Exemple de jeu de tests\n",
    "# Calcul du prix TTC à partir du prix HT"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 584,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "120.0\n"
     ]
    }
   ],
   "source": [
    "print(prix_ttc(100, 20.0))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Calcul du prix HT à partir du prix TTC"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 585,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "100.0\n"
     ]
    }
   ],
   "source": [
    "print(prix_ht(120, 20.0))\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# EXO 1.5 : Conversion Degrés Fahrenheit-Celsius\n",
    "# Question 1\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 586,
   "metadata": {},
   "outputs": [],
   "source": [
    "def fahrenheit_vers_celsius(t):\n",
    "    return (t - 32) * 5 / 9"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Question 2 "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 587,
   "metadata": {},
   "outputs": [],
   "source": [
    "def celsius_vers_fahrenheit(t):\n",
    "    return t * 9 / 5 + 32"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Exemple de jeu de tests\n",
    "# Conversion de Fahrenheit vers Celsius"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 588,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "0.0\n",
      "100.0\n"
     ]
    }
   ],
   "source": [
    "print(fahrenheit_vers_celsius(32))\n",
    "print(fahrenheit_vers_celsius(212))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Conversion de Celsius vers Fahrenheit"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 589,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "32.0\n",
      "212.0\n"
     ]
    }
   ],
   "source": [
    "print(celsius_vers_fahrenheit(0))   \n",
    "print(celsius_vers_fahrenheit(100)) "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# EXO 2.2 : Calcul des mentions\n",
    "# Question 1"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 590,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Eliminé\n",
      "Passable\n",
      "AB\n",
      "B\n",
      "TB\n"
     ]
    }
   ],
   "source": [
    "def mention(note):\n",
    "    if 0 <= note < 10:\n",
    "        return 'Eliminé'\n",
    "    elif 10 <= note < 12:\n",
    "        return 'Passable'\n",
    "    elif 12 <= note < 14:\n",
    "        return 'AB'\n",
    "    elif 14 <= note < 16:\n",
    "        return 'B'\n",
    "    elif 16 <= note <= 20:\n",
    "        return 'TB'\n",
    "    else:\n",
    "        return 'Note invalide'\n",
    "\n",
    "# Exemple de tests\n",
    "print(mention(9))   \n",
    "print(mention(11))  \n",
    "print(mention(13))  \n",
    "print(mention(15))  \n",
    "print(mention(18))  "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Question 2"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 591,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Eliminé\n",
      "Passable\n",
      "AB\n",
      "B\n",
      "TB\n"
     ]
    }
   ],
   "source": [
    "def mention(note):\n",
    "    if 10 <= note < 12:\n",
    "        return 'Passable'\n",
    "    else:\n",
    "        if 0 <= note < 10:\n",
    "            return 'Eliminé'\n",
    "        elif 12 <= note < 14:\n",
    "            return 'AB'\n",
    "        elif 14 <= note < 16:\n",
    "            return 'B'\n",
    "        elif 16 <= note <= 20:\n",
    "            return 'TB'\n",
    "        else:\n",
    "            return 'Note invalide'\n",
    "\n",
    "# Exemple de tests\n",
    "print(mention(9))   \n",
    "print(mention(11))  \n",
    "print(mention(13))  \n",
    "print(mention(15))  \n",
    "print(mention(18))  "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# EXO 2.5 : Volume d’un tétraèdre\n",
    "# Question 1"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 592,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "4.860555523805895\n"
     ]
    }
   ],
   "source": [
    "import math\n",
    "\n",
    "def volume_tetraedre(a, b, c, d, e, f):\n",
    "    # Calcul des termes intermédiaires X, Y, Z\n",
    "    X = b**2 + c**2 - e**2\n",
    "    Y = a**2 + c**2 - f**2\n",
    "    Z = a**2 + b**2 - d**2\n",
    "\n",
    "    # Calcul du volume selon la formule\n",
    "    volume = math.sqrt(4 * a**2 * b**2 * c**2 - a**2 * X - b**2 * Y - c**2 * Z + X * Y * Z) / 12\n",
    "    return volume\n",
    "\n",
    "# Exemple d'un jeu de test (choisir un ensemble de longueurs compatibles pour un tétraèdre)\n",
    "print(volume_tetraedre(3, 3, 3, 3, 3, 3))  \n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 593,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "0.11785113019775793\n",
      "0.9428090415820635\n"
     ]
    }
   ],
   "source": [
    "def volume_tetraedre_regulier(l):\n",
    "    return (l**3 * math.sqrt(2)) / 12\n",
    "\n",
    "# Exemple de tests\n",
    "print(volume_tetraedre_regulier(1))  \n",
    "print(volume_tetraedre_regulier(2))  \n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# EXO 3.2 : Fonction mystère\n",
    "# Question 1 \n",
    "#### La signature de la fonction est f(x: int, y: int) -> int car elle prend deux entiers en entrée (x et y) et retourne un entier z en sortie.\n",
    "#### x et y sont des entiers.\n",
    "#### z est aussi un entier et semble accumuler la somme de quelque chose.\n",
    "#### w est une variable entière utilisée pour itérer de x jusqu'à y. \n",
    "# Question 2\n",
    "#### Effectuons une simulation pour comprendre le comportement de la boucle pour f(3, 6) :\n",
    "#### 1-Initialisation : z = 0 et w = x = 3.\n",
    "#### 2-Boucle :\n",
    "#### Itération 1 : w = 3, donc z = 0 + 3 * 3 = 9, puis w = w + 1 = 4.\n",
    "#### Itération 2 : w = 4, donc z = 9 + 4 * 4 = 25, puis w = 5.\n",
    "#### Itération 3 : w = 5, donc z = 25 + 5 * 5 = 50, puis w = 6.\n",
    "#### Itération 4 : w = 6, donc z = 50 + 6 * 6 = 86, puis w = 7.\n",
    "#### 3-La boucle s'arrête car w = 7, ce qui est supérieur à y = 6.\n",
    "#### La valeur retournée par f(3, 6) est donc 86.\n",
    "#### Question 3\n",
    "#### La boucle s'arrête lorsque w devient supérieur à y. Donc, elle s'arrête à la première valeur de w telle que w > y. En d'autres termes, lorsque w = y + 1.\n",
    "#### Question 4\n",
    "#### Considérons l’appel f(5, 3), où x = 5 et y = 3.\n",
    "#### Dans ce cas, w est initialisé à x = 5, mais la condition w <= y est fausse dès le départ (car 5 > 3), donc la boucle ne s’exécute pas.\n",
    "#### La fonction retourne la valeur initiale de z, qui est 0.\n",
    "#### Cela suggère que la fonction f(x, y) suppose que x ≤ y. Sinon, le résultat retourné est 0.\n",
    "#### Question 5\n",
    "#### D'après notre analyse, la fonction calcule la somme des carrés des entiers allant de x à y, si x ≤ y. Si x > y, elle retourne simplement 0."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# EXO 3.2 : Suite de Fibonacci \n",
    "# Question 1"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 594,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "0\n",
      "1\n",
      "21\n"
     ]
    }
   ],
   "source": [
    "def fibonacci(n):\n",
    "    if n == 0:\n",
    "        return 0\n",
    "    elif n == 1:\n",
    "        return 1\n",
    "    else:\n",
    "        a, b = 0, 1\n",
    "        for _ in range(2, n + 1):\n",
    "            a, b = b, a + b\n",
    "        return b\n",
    "\n",
    "# Exemple de test\n",
    "print(fibonacci(0))  \n",
    "print(fibonacci(1))  \n",
    "print(fibonacci(8))  \n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# EXO 4.5 : Couples et intervalles\n",
    "# Question 1 "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 595,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "0\n",
      "3\n",
      "10\n"
     ]
    }
   ],
   "source": [
    "def nb_couples_intervalle(n, p):\n",
    "    count = 0\n",
    "    for i in range(n, p + 1):\n",
    "        for j in range(i + 1, p + 1):\n",
    "            count += 1\n",
    "    return count\n",
    "\n",
    "# Tests\n",
    "print(nb_couples_intervalle(0, 0))  \n",
    "print(nb_couples_intervalle(2, 4))  \n",
    "print(nb_couples_intervalle(-1, 3)) \n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Question 2 "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 596,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "0\n",
      "3\n",
      "2\n",
      "17\n"
     ]
    }
   ],
   "source": [
    "def nb_couples_divise(n, p):\n",
    "    count = 0\n",
    "    for i in range(n, p + 1):\n",
    "        if i == 0:  # On évite la division par zéro\n",
    "            continue\n",
    "        for j in range(i + 1, p + 1):  # j démarre de i + 1 pour garantir i < j\n",
    "            if j % i == 0:  # Vérifie si i divise j\n",
    "                count += 1\n",
    "    return count\n",
    "\n",
    "# Tests\n",
    "print(nb_couples_divise(4, 6))    \n",
    "print(nb_couples_divise(2, 6))    \n",
    "print(nb_couples_divise(-1, 1))   \n",
    "print(nb_couples_divise(1, 10))   \n",
    "\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Question 3 "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 597,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "couple (2, 3)\n",
      "couple (2, 4)\n",
      "------------\n",
      "2 divise 4!\n",
      "------------\n",
      "couple (2, 5)\n",
      "couple (2, 6)\n",
      "------------\n",
      "2 divise 6!\n",
      "------------\n",
      "couple (3, 2)\n",
      "couple (3, 4)\n",
      "couple (3, 5)\n",
      "couple (3, 6)\n",
      "------------\n",
      "3 divise 6!\n",
      "------------\n",
      "couple (4, 2)\n",
      "couple (4, 3)\n",
      "couple (4, 5)\n",
      "couple (4, 6)\n",
      "couple (5, 2)\n",
      "couple (5, 3)\n",
      "couple (5, 4)\n",
      "couple (5, 6)\n",
      "couple (6, 2)\n",
      "couple (6, 3)\n",
      "couple (6, 4)\n",
      "couple (6, 5)\n",
      "3\n"
     ]
    }
   ],
   "source": [
    "def nb_couples_divise_trace(n, p):\n",
    "    count = 0\n",
    "    for i in range(n, p + 1):\n",
    "        for j in range(n, p + 1):\n",
    "            if i != j:\n",
    "                print(f\"couple ({i}, {j})\")\n",
    "                if j % i == 0:\n",
    "                    print(f\"------------\\n{i} divise {j}!\\n------------\")\n",
    "                    count += 1\n",
    "    return count\n",
    "\n",
    "# Exécution avec traçage\n",
    "print(nb_couples_divise_trace(2, 6))\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Question 4"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 598,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "False\n",
      "True\n",
      "True\n",
      "True\n",
      "False\n"
     ]
    }
   ],
   "source": [
    "def existe_couples_divise_rapide(n, p):\n",
    "    for i in range(n, p + 1):\n",
    "        for j in range(n, p + 1):\n",
    "            if i != j and j % i == 0:\n",
    "                return True\n",
    "    return False\n",
    "\n",
    "# Tests\n",
    "print(existe_couples_divise_rapide(0, 0))    # Résultat attendu : False\n",
    "print(existe_couples_divise_rapide(2, 6))    # Résultat attendu : True\n",
    "print(existe_couples_divise_rapide(-1, 1))   # Résultat attendu : True\n",
    "print(existe_couples_divise_rapide(1, 10))   # Résultat attendu : True\n",
    "print(existe_couples_divise_rapide(21, 34))  # Résultat attendu : False\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Question 5 "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 599,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "False\n",
      "True\n",
      "True\n",
      "True\n",
      "False\n"
     ]
    }
   ],
   "source": [
    "def existe_couples_divise_rapide(n, p):\n",
    "    for i in range(n, p + 1):\n",
    "        for j in range(n, p + 1):\n",
    "            if i != j and j % i == 0:\n",
    "                return True  # Sortie de fonction anticipée\n",
    "    return False  # Sortie anticipée si aucun couple n’est trouvé\n",
    "\n",
    "# Tests (identiques à ceux de la Question 4)\n",
    "print(existe_couples_divise_rapide(0, 0))    # Résultat attendu : False\n",
    "print(existe_couples_divise_rapide(2, 6))    # Résultat attendu : True\n",
    "print(existe_couples_divise_rapide(-1, 1))   # Résultat attendu : True\n",
    "print(existe_couples_divise_rapide(1, 10))   # Résultat attendu : True\n",
    "print(existe_couples_divise_rapide(21, 34))  # Résultat attendu : False\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# EXO 5.2 : Fonction mystère\n",
    "# Question 1 "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 600,
   "metadata": {},
   "outputs": [],
   "source": [
    "def f(a: str) -> int:\n",
    "    \"\"\"\n",
    "    Compte le nombre de chiffres dans la chaîne de caractères a.\n",
    "    \"\"\"\n",
    "    b = 0  # Initialise le compteur de chiffres\n",
    "    for c in a:  # Parcourt chaque caractère dans a\n",
    "        if '0' <= c <= '9':  # Vérifie si le caractère est un chiffre\n",
    "            b += 1  # Incrémente le compteur\n",
    "    return b"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Question 2 "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### Effectuons une simulation manuelle de la boucle en prenant a = '10 août' :\n",
    "#### Initialisation : b = 0.\n",
    "#### Boucle :\n",
    "#### c = '1' : '1' est un chiffre, donc b = b + 1 = 1.\n",
    "#### c = '0' : '0' est un chiffre, donc b = b + 1 = 2.\n",
    "#### c = ' ' : l'espace n'est pas un chiffre, donc b reste à 2.\n",
    "#### c = 'a' : 'a' n'est pas un chiffre, donc b reste à 2.\n",
    "#### c = 'o' : 'o' n'est pas un chiffre, donc b reste à 2.\n",
    "#### c = 'û' : 'û' n'est pas un chiffre, donc b reste à 2.\n",
    "#### c = 't' : 't' n'est pas un chiffre, donc b reste à 2.\n",
    "#### La fonction f('10 août') retourne 2.\n",
    "#### Calcul de f pour d’autres chaînes\n",
    "#### f('bonjour') : Aucun caractère n'est un chiffre, donc f('bonjour') = 0.\n",
    "#### f('un : 1') : Un seul caractère, '1', est un chiffre, donc f('un : 1') = 1.\n",
    "#### f('606060') : Tous les caractères sont des chiffres (6 au total), donc f('606060') = 6."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Question 3 "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 601,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "2\n",
      "0\n",
      "1\n",
      "6\n"
     ]
    }
   ],
   "source": [
    "def compter_chiffres(a: str) -> int:\n",
    "    \"\"\"\n",
    "    Compte et retourne le nombre de caractères numériques (chiffres) dans la chaîne a.\n",
    "\n",
    "    Paramètres :\n",
    "    - a (str) : La chaîne de caractères à analyser.\n",
    "\n",
    "    Retourne :\n",
    "    - int : Le nombre de chiffres dans la chaîne.\n",
    "    \"\"\"\n",
    "    compteur = 0\n",
    "    for caractere in a:\n",
    "        if '0' <= caractere <= '9':\n",
    "            compteur += 1\n",
    "    return compteur\n",
    "\n",
    "# Exemples de tests\n",
    "print(compter_chiffres('10 août'))  # Résultat attendu : 2\n",
    "print(compter_chiffres('bonjour'))  # Résultat attendu : 0\n",
    "print(compter_chiffres('un : 1'))   # Résultat attendu : 1\n",
    "print(compter_chiffres('606060'))   # Résultat attendu : 6\n"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.13.0"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
